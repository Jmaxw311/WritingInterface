<html lang="en">

<head>
    <meta charset="utf-8">

    <title>eReader</title>
    <meta name="description" content="View images of pages from a web server.">
    <meta name="author" content="">

    <style type="text/css">
        .container {
            width: 100%;
            height: 100%;
            position: relative;
            box-shadow: 0 4px 8px 0 rgba(0, 0, 0, 0.2), 0 6px 20px 0 rgba(0, 0, 0, 0.19);
        }

        .center {
            margin: 0;
            position: absolute;
            top: 50%;
            left: 50%;
            -ms-transform: translate(-50%, -50%);
            transform: translate(-50%, -50%);
        }

        .centerh {
            margin: 0;
            position: absolute;
            left: 50%;
            -ms-transform: translate(-50%, 0%);
            transform: translate(-50%, 0%);
        }

        .pageview {
            max-height: 98vh;
            width: auto;
        }

        body {
            background-color: #0e0e0e;
            color: white;
        }

        body>* {
            box-shadow: 0px 0px 5px currentColor;
            background-color: white;
            color: black;
            margin: 2px;
            padding: 2px;
        }
    </style>

</head>

<body>
    <div class="center">
        <div class="container">
            <canvas id="glcanvas" width="480" height="480">Not supported by this browser.</canvas>
        </div>
    </div>

    <script type="text/javascript">
        
        const canvas = document.querySelector("canvas"),
            gl = canvas.getContext("webgl", {
                antialias: true,
                transparent: false
            });

        var strokes = [];
        const frameRate = 1000.0 / 30.0;
        var clockt = Date.now();

        var isMouseDown = false;
        var mouseX = 0.0;
        var mouseY = 0.0;

        var lastPoint = { x: 0, y: 0 };
        var vBuffer = [];

        function frameReady() {
            var n = Date.now();
            if (n - clockt > frameRate) {
                clockt = n;
                return true;
            }
            return false;
        }

        function startStroke() {
            var stroke = { xcoordinates: [], ycoordinates: [] };
            strokes.push(stroke);
            return stroke;
        }

        function currentStroke() {
            if (strokes.length < 1)
                return null;
            return strokes[strokes.length - 1];
        }

        function addPoint(x, y) {
            var stroke = currentStroke();
            if (stroke == null)
                stroke = startStroke();
            stroke.xcoordinates.push(x);
            stroke.ycoordinates.push(y);
            var l = vBuffer.length;
            if (l > 2) {
                vBuffer.push(vBuffer[l - 2]); // re-push previous coord
                vBuffer.push(vBuffer[l - 1]); //
            }
            vBuffer.push(x); // push new coord
            vBuffer.push(y); //
        }

        function onMouseDown(event) {
            if (event.button == 0) {
                isMouseDown = true;
                startStroke();
                addPoint(event.offsetX, event.offsetY);
            }
        }

        function onMouseUp(event) {
            if (event.button == 0)
                isMouseDown = false;
        }

        function onMouseMove(event) {
            if (isMouseDown && frameReady()) {
                addPoint(event.offsetX, event.offsetY);
                updateBuffer();
                drawLines();
            }
        }

        function translate2(vertices, x, y) {
            for (let index = 0; index < vertices.length; index += 2) {
                vertices[(index + 0)] += x;
                vertices[(index + 1)] += y;
            }
            return vertices;
        }

        function concat2(...buffers) {
            const count = buffers.reduce((count, buffer) => {
                return count + buffer.length;
            }, 0);

            const vertices = new Float32Array(count);
            for (let index = 0; index < buffers.length; index++) {
                for (let subindex = 0; subindex < buffers[index].length; subindex++) {
                    vertices[(index * buffers[index].length) + subindex] = buffers[index][subindex];
                }
            }
            return vertices;
        }

        function createStar(count = 5, inner = 0.20, outer = 0.75, phase = 0.0) {
            const scount = count * 2;
            const vertices = new Float32Array(scount * 2);
            for (let index = 0; index < scount; index++) {
                const a = ((index / scount) * Math.PI * 2);
                if (index % 2 === 0) {
                    vertices[(index * 2) + 0] = Math.cos(a + phase) * outer;
                    vertices[(index * 2) + 1] = Math.sin(a + phase) * outer;
                } else {
                    vertices[(index * 2) + 0] = Math.cos(a + phase) * inner;
                    vertices[(index * 2) + 1] = Math.sin(a + phase) * inner;
                }
            }
            return vertices;
        }

        function createPolygon(count = 72, radius = 0.75, phase = 0.0) {
            const vertices = new Float32Array(count * 2);
            for (let index = 0; index < count; index++) {
                const a = ((index / count) * Math.PI * 2);
                vertices[(index * 2) + 0] = Math.cos(a + phase) * radius;
                vertices[(index * 2) + 1] = Math.sin(a + phase) * radius;
            }
            return vertices;
        }

        const vertexShader = gl.createShader(gl.VERTEX_SHADER);
        gl.shaderSource(vertexShader, `
precision mediump float;

attribute vec2 position;

void main(void) {
  gl_Position = vec4(position.x, position.y, 0.0, 1.0);
}`);
        gl.compileShader(vertexShader);

        const vertexStatus = gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS);
        if (!vertexStatus) {
            const vertexError = gl.getShaderInfoLog(vertexShader);
            console.warn("Error in shader:" + vertexError);

            gl.deleteShader(vertexShader);
        }

        const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
        gl.shaderSource(fragmentShader, `
precision highp float;

void main(void) {
  gl_FragColor = vec4(0.0,0.75,1.0,1.0);
}`);
        gl.compileShader(fragmentShader);

        const fragmentStatus = gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS);
        if (!fragmentStatus) {
            const fragmentError = gl.getShaderInfoLog(fragmentShader);
            console.warn("Error in shader:" + fragmentError);

            gl.deleteShader(fragmentShader);
        }

        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);

        const linked = gl.getProgramParameter(program, gl.LINK_STATUS);
        if (!linked) {
            const lastError = gl.getProgramInfoLog(program);
            console.warn("Error in program linking:" + lastError);

            gl.deleteProgram(program);
        }

        /*const*/var COUNT = 0;//6;

        const buffer = gl.createBuffer();
        const attribPosition = gl.getAttribLocation(program, "position");

        function updateBuffer() {
            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
            //gl.bufferData(gl.ARRAY_BUFFER, createPolygon(COUNT, 0.15), gl.STATIC_DRAW);
            data = new Float32Array(vBuffer);
            COUNT = data.length;
            gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW);

            gl.vertexAttribPointer(attribPosition, 2, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(attribPosition);
            
            drawLines();
        }
        updateBuffer();
        
        function drawLines() {

            gl.viewport(0, 0, 480, 480);

            gl.useProgram(program);

            gl.clearColor(0.0, 1.0, 1.0, 1.0);
            gl.clear(gl.COLOR_BUFFER_BIT);

            gl.lineWidth(1.5);

            gl.drawArrays(gl.LINES, 0, COUNT);
            console.log("drawing " + (COUNT / 4) + " line segments");
        }
        
        function loop(timestamp) {
            var n = Date.now();
            if (n - clockt > frameRate) {
                clockt = n;
                if (vBuffer.length > 2) {
                    updateBuffer();
                    drawLines();
                }
            }
        }

        function start() {
            canvas.addEventListener('mousedown', onMouseDown);
            canvas.addEventListener('mouseup', onMouseUp);
            canvas.addEventListener('mousemove', onMouseMove);
            //window.requestAnimationFrame(loop)
        }
        start();

        addPoint(100, 100);
        addPoint(100, 200);
        addPoint(200, 200);
        addPoint(200, 100);
        updateBuffer();
        drawLines();

    </script>
</body>

</html>